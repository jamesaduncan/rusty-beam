# Rusty-Beam TODO List

- [x] Fix PUT bug that exists in more complex examples - specifically, when the HTML that gets PUT in the HTTP body is a <td>...</td>.
- [x] What is that extra byte? (Fixed: dom_query library was adding trailing newline)
- [x] Pluggable authentication - Basic Auth implemented
- [x] Google OAuth2 authentication plugin
- [x] Authorization with paths, methods and selectors
- [x] Update the configuration so that the Host header can direct the server to the relevant director
- [x] Gracefully handle failures to start when there is already something listening on the socket
- [x] Fix compilation warning about unused host_name field in HostConfig struct
- [x] Make sure the server is compliant with the HTTP spec (except intentional Range header design).
- [x] Refactor the code base to split it out into multiple files. One single file is getting unweildy.
- [x] kill -HUP the process should have rusty-beam re-read all of the config files
- [x] Write a library to extract data strutures from webpages that have itemprop itemtype itemid etc, including nested structures.
- [x] The config file should be a cmdline parameter & have no default. rusty-beam should fail if unspecified.
- [x] The "realm" for basic authentication should be configurable in the config file.
- [x] The content of the Server header should default to rusty-beam/version, but it should be configurable too
- [x] The plugin interface should be unified [See * below for more info].
    - Basically, all plugins should take a Request, and handle it as a unified interface; I think so far in the case of all plugins, an Ok that would return basically nothing and processing would continue, or an Err that would return a Response object, with the various appropriate error codes and so on. Really, all of the response handling should be done like this. What is required is to be able to order the plugins in the configuration file, rather than naming them with particular types.
    - Plugins should also be pluggable, so that you can have nested plugins. For example, a configuration could create a plugin structure that looks vaguely like this:
        - basic-authentication
        - authorization
        - request-handler
            - selector-handler
            - file-handler
        - access-log
    - If a response is generated by a plugin, the plugins shouldn't be short-circuited. Instead a different method -- if it is defined -- should be called in the interface, and both the Request and the Response should be provided. That would allow plugins like the access-log plugin to still work.
    - Plugins should be able to communicate via some mechanism back to the main process to get things like configuration data.
- [x] Directory plugin, that matches and executes or doesn't match and skips.
- [x] The various plugins make a lot of noise on STDOUT (Fixed: added -v/--verbose flag, quiet by default)
- [x] The apache access log plugin isn't recording the user who accesses the page correctly.
- [x] Make sure all the plugins have tests
- [x] Make sure we serve 206 Partial Content headers, and that when we do we set the Content-Range header as appropriate.
- [x] Make it possible to get a WebSocket to a document, that gives you updates whenever you subscribe to particular selectors.
- [ ] Fully implement the compression plugin
- [x] Redirect plugin doesn't parse HTML rules files
- [x] Authorization plugin has limited HTML parsing for rules
- [x] Make sure that all the schemas that rusty-beam relies upon are documented in docs/
- [x] Remove the UserDB schema. It is just a container and is therefore not needed.
- [x] Remove the RedirectRules schema. It is just a container and is therefore not needed.
- [x] Extract the directory plugin handling code from main.rs into its own plugin properly. It has been extracted, but now it won't allow nested plugins. It should.
- [x] Fix file-handler DELETE to return 204 No Content instead of 200 OK for successful deletions

