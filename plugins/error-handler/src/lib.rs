use rusty_beam_plugin_api::{Plugin, PluginRequest, PluginContext, create_plugin};
use async_trait::async_trait;
use hyper::{Body, Response};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// Plugin for custom error pages and error logging
#[derive(Debug)]
pub struct ErrorHandlerPlugin {
    name: String,
    error_pages: HashMap<u16, String>,
    log_errors: bool,
}

impl ErrorHandlerPlugin {
    pub fn new(config: HashMap<String, String>) -> Self {
        let name = config.get("name").cloned().unwrap_or_else(|| "error-handler".to_string());
        let log_errors = config.get("log_errors")
            .map(|v| v.parse().unwrap_or(true))
            .unwrap_or(true);
        
        let mut error_pages = HashMap::new();
        
        // Parse error page mappings from config
        for (key, value) in &config {
            if key.starts_with("error_page_") {
                if let Ok(status_code) = key[11..].parse::<u16>() {
                    error_pages.insert(status_code, value.clone());
                }
            }
        }
        
        // Default error pages
        if error_pages.is_empty() {
            error_pages.insert(404, "404.html".to_string());
            error_pages.insert(500, "500.html".to_string());
            error_pages.insert(403, "403.html".to_string());
        }
        
        Self { name, error_pages, log_errors }
    }
    
    /// Load custom error page content
    fn load_error_page(&self, status_code: u16, context: &PluginContext) -> Option<String> {
        if let Some(error_page) = self.error_pages.get(&status_code) {
            // Try to find the error page in the document root
            let document_root = context.get_config("document_root").unwrap_or("./");
            let error_path = Path::new(document_root).join(error_page);
            
            if let Ok(content) = fs::read_to_string(&error_path) {
                return Some(content);
            }
        }
        None
    }
    
    /// Generate default error page HTML
    fn generate_default_error_page(&self, status_code: u16, reason: &str) -> String {
        format!(
            r#"<!DOCTYPE html>
<html>
<head>
    <title>Error {}</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }}
        .error-container {{
            background-color: white;
            padding: 30px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }}
        h1 {{
            color: #d32f2f;
            border-bottom: 2px solid #d32f2f;
            padding-bottom: 10px;
        }}
        .error-code {{
            font-size: 48px;
            font-weight: bold;
            color: #d32f2f;
        }}
    </style>
</head>
<body>
    <div class="error-container">
        <div class="error-code">{}</div>
        <h1>{}</h1>
        <p>We apologize for the inconvenience. Please try again later or contact support if the problem persists.</p>
        <p><small>Error generated by rusty-beam server</small></p>
    </div>
</body>
</html>"#,
            status_code, status_code, reason
        )
    }
    
    /// Log error details
    fn log_error(&self, status_code: u16, path: &str, context: &PluginContext) {
        if self.log_errors {
            println!("[ErrorHandler] {} error for path: {} (host: {})", 
                     status_code, path, context.host_name);
        }
    }
}

#[async_trait]
impl Plugin for ErrorHandlerPlugin {
    async fn handle_request(&self, _request: &mut PluginRequest, _context: &PluginContext) -> Option<Response<Body>> {
        // Error handler doesn't intercept requests, only handles responses
        None
    }
    
    async fn handle_response(&self, request: &PluginRequest, response: &mut Response<Body>, context: &PluginContext) {
        let status = response.status();
        let status_code = status.as_u16();
        
        // Handle error status codes
        if status_code >= 400 {
            self.log_error(status_code, &request.path, context);
            
            // Try to load custom error page
            if let Some(error_content) = self.load_error_page(status_code, context) {
                // Replace response body with custom error page
                *response = Response::builder()
                    .status(status)
                    .header("Content-Type", "text/html; charset=utf-8")
                    .body(Body::from(error_content))
                    .unwrap();
            } else {
                // Generate default error page
                let reason = status.canonical_reason().unwrap_or("Unknown Error");
                let error_html = self.generate_default_error_page(status_code, reason);
                
                *response = Response::builder()
                    .status(status)
                    .header("Content-Type", "text/html; charset=utf-8")
                    .body(Body::from(error_html))
                    .unwrap();
            }
        }
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

// Export the plugin creation function
create_plugin!(ErrorHandlerPlugin);